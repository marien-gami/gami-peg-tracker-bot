// alerts/pegWatcher.jsimport "dotenv/config";import { PEG_CONFIGS } from "../pegConfig.js";import { sendTelegramMessage } from "../telegram.js";const chatId = process.env.CHAT_ID;const GECKO_BASE =  process.env.GECKO_API_BASE || "https://api.geckoterminal.com/api/v2";const CHECK_INTERVAL_SECONDS = parseInt(  process.env.CHECK_INTERVAL_SECONDS || "60",  10);const CHECK_EVERY_MS = CHECK_INTERVAL_SECONDS * 1000;// cooldown par pool: pool_addr -> { last_dir, last_ts }const cooldownState = {};// -------- Helpers GeckoTerminal --------function parseRows(json) {  if (!json || typeof json !== "object") return [];  if (Array.isArray(json.data)) return json.data;  if (json.data) return [json.data];  return [];}function buildIncludedIndex(included) {  const index = {};  if (!Array.isArray(included)) return index;  for (const it of included) {    if (!it || !it.type || !it.id) continue;    const attrs = it.attributes || {};    if (it.type === "token") {      index[it.id] = {        type: "token",        address: (attrs.address || "").toLowerCase(),        symbol: attrs.symbol || ""      };    } else if (it.type === "dex") {      index[it.id] = {        type: "dex",        name: attrs.name || it.id      };    }  }  return index;}function tokenAddrFromRel(rel, includedIndex) {  const id = rel?.data?.id;  if (!id) return null;  const obj = includedIndex[id];  if (!obj || obj.type !== "token") return null;  return obj.address || null;}function tokenSymFromRel(rel, includedIndex) {  const id = rel?.data?.id;  if (!id) return null;  const obj = includedIndex[id];  if (!obj || obj.type !== "token") return null;  return obj.symbol || null;}function dexNameFromRel(rel, includedIndex) {  const id = rel?.data?.id;  if (!id) return "dex";  const obj = includedIndex[id];  if (!obj || obj.type !== "dex") return id;  return obj.name || id;}// -------- Core: fetch + calcul des alertes pour une config --------async function fetchPoolsMulti(config) {  const network = config.network;  const poolsList = config.pools.join(",");  const url = `${GECKO_BASE}/networks/${network}/pools/multi/${poolsList}?include=base_token,quote_token,dex`;  const res = await fetch(url, {    headers: {      Accept: "application/json"    }  });  if (!res.ok) {    console.error(      `‚ùå GeckoTerminal HTTP error for ${config.name}:`,      res.status,      await res.text()    );    return null;  }  try {    const json = await res.json();    return json;  } catch (err) {    console.error("‚ùå Failed to parse GeckoTerminal JSON:", err);    return null;  }}function buildAlertsForConfig(config, json) {  const rows = parseRows(json);  const includedIndex = buildIncludedIndex(json?.included);  const BASE = config.baseToken.address;  const PEG = config.pegToken.address;  const baseSymRef = config.baseToken.symbol;  const pegSymRef = config.pegToken.symbol;  const th = config.thresholdPct;  const basePrice = 1.0;  const low = basePrice * (1 - th / 100);  const high = basePrice * (1 + th / 100);  const alerts = [];  for (const p of rows) {    const a = p.attributes || {};    const r = p.relationships || {};    const baseAddr = tokenAddrFromRel(r.base_token, includedIndex);    const quoteAddr = tokenAddrFromRel(r.quote_token, includedIndex);    const baseSym =      tokenSymFromRel(r.base_token, includedIndex) || baseSymRef || "BASE";    const quoteSym =      tokenSymFromRel(r.quote_token, includedIndex) || pegSymRef || "QUOTE";    const dexName = dexNameFromRel(r.dex, includedIndex);    const address =      a.address || (p.id && p.id.split("_")[1]) || "";    // prix USD du token surveill√© (USDe) et du peg (USDT)    let trackedUsd = NaN;    let pegUsd = NaN;    if (baseAddr === BASE)      trackedUsd = parseFloat(a.base_token_price_usd);    if (quoteAddr === BASE)      trackedUsd = parseFloat(a.quote_token_price_usd);    if (baseAddr === PEG)      pegUsd = parseFloat(a.base_token_price_usd);    if (quoteAddr === PEG)      pegUsd = parseFloat(a.quote_token_price_usd);    if (!Number.isFinite(trackedUsd) || !Number.isFinite(pegUsd)) {      continue;    }    const px = trackedUsd / pegUsd;    const devPct = Math.abs((px - 1) * 100);    let direction = "";    if (px < low) direction = "down";    else if (px > high) direction = "up";    alerts.push({      configName: config.name,      pool_addr: address,      dex: dexName,      pair: `${baseSym}/${quoteSym}`,      price: px,      devPct,      direction    });  }  return alerts;}function applyCooldown(alerts, config) {  const now = Date.now();  const cooldownMin = config.cooldownMinutes;  const toSend = [];  for (const al of alerts) {    if (!al.direction) continue; // dans le seuil    const key = al.pool_addr;    const s = cooldownState[key] || {};    const mins = (now - (s.last_ts || 0)) / 60000;    if (al.direction !== s.last_dir || mins >= cooldownMin) {      toSend.push(al);      cooldownState[key] = { last_dir: al.direction, last_ts: now };    }  }  return toSend;}// -------- Envoi Telegram --------async function sendAlertsTelegram(alertsByConfig) {  for (const group of alertsByConfig) {    const { config, alerts } = group;    if (!alerts.length) continue;    const th = config.thresholdPct;    const header = `‚ö†Ô∏è <b>${config.baseToken.symbol} depeg detected (¬±${th}% threshold)</b>`;    const lines = alerts.map((al) => {      const arrow = al.direction === "down" ? "‚¨áÔ∏è" : "‚¨ÜÔ∏è";      const url = `https://www.geckoterminal.com/${config.network}/pools/${al.pool_addr}`;      return `${arrow} <b>${al.dex}</b> ‚Äî ${al.pair}: <b>${al.price.toFixed(        6      )} ${config.pegToken.symbol}</b> (deviation ${al.devPct.toFixed(        2      )}%) ‚Ä¢ <a href="${url}">pool</a>`;    });    const msg = [header, ...lines].join("\n");    await sendTelegramMessage(chatId, msg);  }}// -------- Boucle principale --------async function tickOnce() {  const results = [];  for (const config of PEG_CONFIGS) {    try {      const json = await fetchPoolsMulti(config);      if (!json) continue;      const alerts = buildAlertsForConfig(config, json);      const cooled = applyCooldown(alerts, config);      results.push({ config, alerts: cooled });    } catch (err) {      console.error(`‚ùå Error processing peg config "${config.name}":`, err);    }  }  await sendAlertsTelegram(results);}export function startPegWatcher() {  console.log(    `üöÄ Peg watcher started (GeckoTerminal). Check every ${CHECK_INTERVAL_SECONDS}s.`  );  tickOnce();  setInterval(tickOnce, CHECK_EVERY_MS);}